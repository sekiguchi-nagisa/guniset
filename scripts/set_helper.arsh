
type Range(f: String, l: String) {
    let first = $f
    let last = $l
    let firstN = $first.toInt(16)!
    let lastN = $last.toInt(16)!
}

function compare(o : Range) : Int for Range {
    return $this.lastN.compare($o.firstN)
}

function try_merge(o : Range) : Range? for Range {
    if $this.lastN + 1 == $o.firstN {
        # merge range
        return new Range($this.first, $o.last)
    }
    return $none
}

function minimize(map: [String: [Range]]) {
    var keys : [String]
    for key, _ in $map {
        $keys.add($key)
    }

    for key in $keys {
        var new_values: [Range]
        var old_values = $map[$key].sortBy(function(x, y)=>$x.compare($y))
        for value in $old_values {
            if $new_values.empty() {
                $new_values.add($value)
                continue
            }
            if let v = $new_values.peek().try_merge($value) {
                $new_values.pop()
                $new_values.push($v)
                continue
            }
            $new_values.add($value)
        }
        $map[$key] = $new_values
    }
}

function generate_golden(filename: String, prefix: String, output_dir: String) {
    var prop_map : [String: [Range]]
    var count =0 
    for line in new FD($filename) {
        $count++
        ($line.empty() || $line.startsWith('#')) && continue
        var matched = $/^(?<first>[0-9A-F]+)(\.\.(?<last>[0-9A-F]+))?[ ]*;[ ]+(?<prop>([a-zA-Z][_a-zA-Z0-9]*)) *[#;].+$/.match($line) ?? 
            { echo failed at $count: $line; exit 1; }
        var first = $matched.named('first')!
        var last =  $matched.named('last') ?? $first
        var sc = $matched.named('prop')!
        $prop_map.putIfAbsent($sc, new [Range]())
        $prop_map[$sc].add(new Range($first, $last))
    }

    # check cate
    for _, values in $prop_map {
        assert ! $values.empty()
    }

    # merge
    $minimize($prop_map)

    # output
    for prop, values in $prop_map {
        for v in $values {
            echo "{ 0x${v.first}, 0x${v.last} },"
        } with > $output_dir/${prefix}_${$prop.lower()}.golden
        echo "$prefix:$prop" > $output_dir/${prefix}_${$prop.lower()}.test
    }
}

function generate_enum_golden(filename: String, prefix: String, output_dir: String) {
    var propertySet : [String:Bool]
    var count =0 
    for line in new FD('./DerivedNormalizationProps.txt') {
        $count++
        ($line.empty() || $line.startsWith('#')) && continue
        var matched = $/^(?<first>[0-9A-F]+)(\.\.(?<last>[0-9A-F]+))?[ ]*;[ ]+(?<prop>([a-zA-Z][_a-zA-Z0-9]*)) *[;#].+$/.match($line) ?? {echo failed at $count: $line; exit 1;}
        var sc = $matched.named('prop')!
        $propertySet.putIfAbsent($sc, $true)
    }
    var properties : [String] 
    for k, _ in $propertySet {
        $properties.add($k)
    }
    $properties.sort()

    printf "%s\n" $properties > $output_dir/$prefix.golden
}